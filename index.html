<html>
	<head>
		<title>Burger Bus</title>
		<link href="style.css" type="text/css" rel="stylesheet" />
		<script src='color.js'></script>
      <script src='//code.jquery.com/jquery-1.10.2.js'></script>
		<script src='//code.jquery.com/ui/1.10.3/jquery-ui.js'></script>
		<script>
      function progressBar(value, max, width) {
         var percent = value / max;
         var displayPercent = Math.floor(percent * 100);

         var fillWidth = width * percent;

			return {"fillWidth": fillWidth, "percent": displayPercent};
      }

		function getTime(seconds) {
			var minutes = Math.floor(seconds / 60);
			var seconds = Math.floor(seconds - minutes * 60);

			if (minutes < 10) {
				minutes = "0" + minutes;
			}

			if (seconds < 10) {
				seconds = "0" + seconds;
			}

			return minutes + ":" + seconds;	
		}

      function overlaps(obj1, obj2) {
			var ax1 = obj1.left;
			var ay1 = obj1.top;	
         var ax2 = ax1 + 100;
         var ay2 = ay1 + 100;

			var bx1 = obj2.left;
			var by1 = obj2.top;
         var bx2 = bx1 + 100;
         var by2 = by1 + 100;

         var comp0 = ax1 < bx2;
         var comp1 = ax2 > bx1;
         var comp2 = ay1 < by2;
         var comp3 = ay2 > by1;

         return (comp0 && comp1 && comp2 && comp3);
      }

		function withinBounds(obj1, obj2) {
			var ax1 = obj1.left;
			var ay1 = obj1.top;	
         var ax2 = ax1 + 100;
         var ay2 = ay1 + 100;

			var bx1 = obj2.left;
			var by1 = obj2.top;
         var bx2 = bx1 + obj2.width;
         var by2 = by1 + obj2.height;

			var comp0 = ax1 < bx1;
			var comp1 = ax2 > bx2;
			var comp2 = ay1 < by1;
			var comp3 = ay2 > by2;

			return !(comp0 || comp1 || comp2 || comp3);
		}

		function bindMe(obj, method) {
			return function() {
				return method.apply(obj);
			};
		}

		function soundBuffer(filename) {
    		var snd = new Audio(filename);
			
			snd.addEventListener('ended', function() {
				delete snd;
			}, false);

			snd.play();
		}

		var mechanics = new function() {
			this.nextOrder = null;
		
			// values in seconds indicating how long a customer will wait for an order (until it expires)
			this.orderMaxAgeUpper = 180; // maximum for order wait time
			this.orderMaxAgeLower = 180; // minimum value for random order wait time

			this.orderBurgerCountUpper = 3; // maximum number of burgers per order
			this.orderBurgerCountLower = 1; // least number of burgers per order

			this.paused = false; // system wide pause setting

			this.maxPattiesOnPrep = 5; // maximum number of patties on the prep table at once
			this.prepTableExpire = 120; // number of seconds a patty lives on the prep table

			// ms for each cook() iteration at diff oven temps
			this.griddleTempHigh = 300; 
			this.griddleTempMed = 800;
			this.griddleTempLow = 1500;

			this.pattyMaxDone = 120; // max doneness of a side before we blink out

			// scoring
			this.pattyScores = {
				danger: {
					score: 0,
					range: 25,
					yulp: 1
				},
				bad: {
					score: 0,
					range: 15,
					yulp: 2
				},
				ok: {
					score: 10,
					range: 8,
					yulp: 3
				},
				great: {
					score: 20,
					range: 5,
					yulp: 4
				},
				perfect: {
					score: 50,
					range: 0,
					yulp: 5
				}
			};		
		};

		var prepTable = new function() {
			this.patties = [];
			this.pattyCount = 0;
			this.timer = null;

			this.addPatty = function(patty) {
				if (this.patties.length < mechanics.maxPattiesOnPrep) {
					var newId = this.pattyCount;
					this.pattyCount++;
					patty.id = "prep" + newId;
					patty.idHash = "#" + patty.id;
					patty.max = mechanics.prepTableExpire;
					patty.remain = patty.max;
					this.patties.push(patty);
					this.draw();

					if (!mechanics.paused) {
						this.startTimer();
					}

					if (this.patties.length == mechanics.maxPattiesOnPrep) {
						$("#preptable").droppable("disable");
					}
				} 
			};

			this.getPatty = function(id) {
				for (var x = 0; x < this.patties.length; x++) {
					if (this.patties[x].id == id) {
						return this.patties[x];
					}
				}

				return false;
			};

			this.getOldestPatty = function() {
				var curTime = 0;
				var curId = "";

				for (var x = 0; x < this.patties.length; x++) {
					var secsOld = this.patties[x].max - this.patties[x].remain;

					if (curTime == 0) {
						curTime = secsOld;
						curId = this.patties[x].id;
					} else if (secsOld > curTime) {
						curTime = secsOld;
						curId = this.patties[x].id;
					}
				}

				return this.getPatty(curId);
			}

			this.removePatty = function(id) {
				if (id) {
					var ret = null;

					// remove a specific patty from the array
					var tmp = [];

					for (var x = 0; x < this.patties.length; x++) {
						if (this.patties[x].id != id) {
							tmp.push(this.patties[x]);
						} else {
							ret = this.patties[x];
						}
					}

					this.patties = tmp;
				} 
			
				$("#" + id).remove();

				if (this.patties.length === 0) {
					this.stopTimer();
				}

				this.draw();	

				if (this.patties.length < mechanics.maxPattiesOnPrep) {
					$("#preptable").droppable("enable");
				}

				return ret;
			};

			this.removeOldestPatty = function() {
				return this.removePatty(this.getOldestPatty().id);
			};

			this.startTimer = function() {
				if (this.timer === null) {
					this.timer = window.setInterval(bindMe(this, this.decRemain), 1000);
				}
			};

			this.decRemain = function() {
				for (var x = 0; x < this.patties.length; x++) {
					if (this.patties[x].remain > 0) {
						this.patties[x].remain--;
					} else {
						this.removePatty(this.patties[x].id);
					}
				}

				this.draw();
			};

			this.stopTimer = function() {
				if (this.timer !== null) {
					clearInterval(this.timer);
				}

				this.timer = null;
			}

			this.draw = function() {
				for (var x = 0; x < this.patties.length; x++) {
					if ($(this.patties[x].idHash).length > 0) {
						// update the patty div on preptable
						var pb = progressBar(this.patties[x].remain, this.patties[x].max, $("#preptable").width());

						$(this.patties[x].idHash + " .progressBar")
							.css("width", pb.fillWidth)
							.html(pb.percent + "%");
					} else {
						// draw the patty div on preptable
						var pb = progressBar(this.patties[x].remain, this.patties[x].max, $("#preptable").width());

						$("<div></div>")
							.attr("id", this.patties[x].id)
							.addClass("prepPatty")
         				.append("<div class='progressBar' style='height: 100%; background-color: red; width: " + pb.fillWidth + "px;'>" + pb.percent + "%</div>")
							.appendTo("#preptable");
					}
				}
			};
		};

		var Order = function() {
			this.number = 0;
			this.burgerCount = 0;
			this.age = 0;
			this.maxAge = 0;
			this.filled = false;
			this.result = "";

			this.draw = function() {
				$("#currentOrder .orderNumber").html(this.number);
				$("#currentOrder .burgerCount").html(this.burgerCount);
				$("#currentOrder .orderAge").html(getTime(this.age));
			};
		};

		var orderCollection = new function() {
			this.orders = [];
			this.orderCounter = 0;
			this.currentOrder = "";
			this.timer = null;

			this.startTimer = function() {
				if (this.timer === null) {
					this.timer = window.setInterval(bindMe(orderCollection, orderCollection.ageOrders), 1000);
				}
			};

			this.stopTimer = function() {
				if (this.timer !== null) {
					clearInterval(this.timer);
				}

				this.timer = null;
			};

			this.ageOrders = function() {
				for (var x = 0; x < this.orders.length; x++) {
					this.orders[x].age++;

					// checking for expiring orders here
					var expiring = false;

					if (this.orders[x].age > this.orders[x].maxAge & !this.orders[x].filled) {
						if (this.orders[x].number == this.currentOrder) {
							this.currentOrder = "";
						}

						$("#currentOrderBG").fadeIn(200).fadeOut(200).fadeIn(200).fadeOut(200).fadeIn(200).fadeOut(200, function() { 
							soundBuffer("boo.mp3");
							orderCollection.draw(); 
						});

						this.removeOrder(this.orders[x].number);
						expiring = true;
					}
				}

				if (!expiring) {
					this.draw();
				}
			};

			this.draw = function() {
				$("#orderCollection .totalOrders").html(this.orderCount());
				$("#orderCollection .burgersAllDay").html(this.burgerTotal());
				$("#orderCollection .ordersFilled").html(this.ordersFilled());

				if (this.currentOrder == "") {
					var tmp = this.getOldest();

					if (tmp) {
						this.currentOrder = tmp.number;
					} else {
						$("#currentOrder .orderNumber").html("-");
						$("#currentOrder .burgerCount").html("-");
						$("#currentOrder .orderAge").html("-");
					}
				}

				// draw the order if there is one
				if (this.currentOrder != "") {
					this.getOrder(this.currentOrder).draw();
				}	
			};

			this.orderCount = function() {
				var ret = 0;

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].filled === false) {
						ret++;
					}
				}

				return ret;
			}

			this.ordersFilled = function() {
				var ret = 0;

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].filled) {
						ret++;
					}
				}

				return ret;
			};

			this.burgerTotal = function() {
				var ret = 0;

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].filled === false) {
						ret += this.orders[x].burgerCount;					
					}
				}

				return ret;
			}

			this.addOrder = function(order) {
				// generate an order number
				order.number = ++this.orderCounter;

				// add to the orders array
				this.orders.push(order);

				// start the timer if its not already
				if (this.timer === null) {
					this.startTimer();
				}

				this.draw();

				soundBuffer("bell.mp3");

				if (!mechanics.paused) {
					mechanics.nextOrder = window.setTimeout(function() {
						var order = new Order();
						order.burgerCount = Math.floor(Math.random() * (mechanics.orderBurgerCountUpper - mechanics.orderBurgerCountLower)) + mechanics.orderBurgerCountLower;
						order.maxAge = Math.floor(Math.random() * (mechanics.orderMaxAgeUpper - mechanics.orderMaxAgeLower)) + mechanics.orderMaxAgeLower;
						orderCollection.addOrder(order);
					}, Math.floor(Math.random() * 8000) + (Math.random() * 80000) + 20000);
				}
			};
		
			this.removeOrder = function(number) {
				// remove order identified by the order#
				var tmp = [];

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].number != number) {
						tmp.push(this.orders[x]);
					}			
				}

				this.orders = tmp;
			};

			this.getOrder = function(number) {
				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].number == number) {
						return this.orders[x];
					}
				}
			};

			this.getOldest = function() {
				var orderNum = "";
				var orderTime = 0;

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].filled === false) {
						if (orderTime == 0) {
							orderTime = this.orders[x].age;
							orderNum = this.orders[x].number;
						} else {
							if (this.orders[x].age < orderTime) {
								orderTime = this.orders[x].age;
								orderNum = this.orders[x].number;
							}
						}
					}
				}

				if (orderNum != "") {
					return this.getOrder(orderNum);	
				} else {
					return false;
				}
			};

			this.fillOrder = function(patties) {
				// clean up the order
				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].number == this.currentOrder) {
						this.orders[x].filled = true;
						this.currentOrder = "";
						this.draw();

						soundBuffer("orderup.mp3");

						break;
					}
				}

				// compute the score
				var score = 0;
				var yulp = [];

				for (var x = 0; x < patties.length; x++) {
					score += patties[x].score();					
				
					yulp.push(patties[x].yulp());
				}

				var tmp = Math.min.apply(0, yulp);

				player.score += score;
				player.yulps.push(tmp);

				$("<span id='addScore'>+" + score + "</span>")
					.appendTo("#scoreBox")
					.fadeIn(200)
					.fadeOut(200)
					.fadeIn(200)
					.fadeOut(200)
					.fadeIn(200)
					.fadeOut(200, function() {
						player.scoreBoard.draw();
						$(this).remove();
					});
			};
		};

		var player = new function() {
			this.name = "";
			this.score = 0;
			this.yulps = [];

			this.scoreBoard = new function() {
				this.good = 0;
				this.bad = 0;
				this.garbage = 0;
				this.griddleTimeout = 0;
				this.prepTableTimeout = 0;
				this.servedCustomers = 0;
				this.satisfiedCustomers = 0;
				this.unsatisfiedCustomers = 0;
				this.tips = 0;
			
				this.draw = function() {
					$("#scoreBoard .good").html(this.good);	
					$("#scoreBoard .bad").html(this.bad);	
					$("#scoreBoard .garbage").html(this.garbage);	

					$("#curScore").html(player.score);
				};
			};
		};

		var griddle = new function() {
			this.patties = [];
			this.griddleOn = false;
			this.timer = null;
			this.cookInterval = 0;
			this.pattyCount = 0;

			this.getID = function() {
				var ret = this.pattyCount;

				this.pattyCount++;

				return ret;
			};

			this.turnOn = function(interval) { 
            if (this.timer === null) {
               this.timer = window.setInterval(bindMe(griddle, griddle.cook), interval);
					this.griddleOn = true;
					this.cookInterval = interval;

					if (this.patties.length > 0) {
						soundBuffer("patty.mp3");
					}
            }
			};

			this.turnOff = function() {
				if (this.timer != null) {
					clearInterval(this.timer);
				}

				this.timer = null;
				this.griddleOn = false;
			};

			this.cook = function() {
				if (this.patties.length > 0) {
					for (var x = 0; x < this.patties.length; x++) {
						this.patties[x].cook();
					}
				} 

				this.draw();
			};

			this.addPatty = function(patty) {
				var id = this.getID();
				patty.id = "patty" + id;
				patty.idHash = "#patty" + id;

				this.patties.push(patty);

				this.draw();

				if (this.griddleOn) {
					soundBuffer("patty.mp3");
				}
			};

			this.removePatty = function(id) {
				var ret = null;
				var patties = [];

				for (var x = 0; x < this.patties.length; x++) {
					if (this.patties[x].id != id) {
						patties.push(this.patties[x]);
					} else {
						ret = this.patties[x];
					}
				}

				this.patties = patties;

				this.draw();

				return ret;
			};

			// v2 of the draw function.  updates and creates new patties
			this.draw = function() {
				// if we have patties to draw
				if (this.patties.length > 0) {
					for (var x = 0; x < this.patties.length; x++) {
						// if the patty has already been drawn, refresh it's content
						if ($(this.patties[x].idHash).length > 0) {
							$(this.patties[x].idHash).html("<span class='curside'>" + this.patties[x].curSide + "%</span><span class='flipside'>" + this.patties[x].flipSide + "%</span>");
							var step = Math.floor(this.patties[x].flipSide / 10);

							if (step > 10) {
								$(this.patties[x].idHash).css("background-color", "black");	
							} else {
								$(this.patties[x].idHash).css("background-color", colorGradient("#FF0000", "#570A0A", step, 10));
							}
						// otherwise, draw it new
						} else {
							$("<div><span class='curside'>" + this.patties[x].curSide + "%</span><span class='flipside'>" + this.patties[x].flipSide + "%</span></div>")
								.attr("id", this.patties[x].id)
								.css("top", this.patties[x].posTop + "px")
								.css("left", this.patties[x].posLeft + "px")
								.css("background-color", "#FF0000")
								.addClass('patty')
								.draggable({
									containment: "#workspace",
    								revert: 'invalid',
									stop: function(e, ui) {
										$(this).draggable('option', 'revert', 'invalid');

										if (!mechanics.paused) {
											// this is to avoid a bug where you can mouseout of the patty
											// and the mouseup never registers
											for (var x = 0; x < griddle.patties.length; x++) {
												if (griddle.patties[x].id == $(this).attr("id")) {
													if (e.toElement.id != "preptable") {
														griddle.patties[x].cookable = true;
													}
												}
											}
										}
									}
								})
								.droppable({
									greedy: true,
									tolerance: 'touch',
									drop: function(event, ui) {
										ui.draggable.draggable('option', 'revert', true);
									}
								})
								.css("position", "absolute")
								.appendTo('#griddle');
						}
					}
				}
			}
		};

		var Patty = function(posTop, posLeft) {
			this.id = "";
			this.idHash = "";
			this.posTop = posTop || 0;
			this.posLeft = posLeft || 0;
			this.curSide = 0;
			this.flipSide = 0;
			this.cookable = true;
			this.dying = false;
			
			this.cook = function() {
				if (this.cookable !== false) {
					this.curSide++;
				}

				if (this.curSide > mechanics.pattyMaxDone && this.cookable == true) {
					if (this.dying === false ) {
						this.cookable = false;
						this.dying = true;

						$(this.idHash)
							.fadeOut(300).fadeIn(300)
							.fadeOut(300).fadeIn(300)
							.fadeOut(300).fadeIn(300)
							.fadeOut(300).fadeIn(300)
							.fadeOut(300).fadeIn(300, function() {
								// remove the element
								griddle.removePatty(this.id);
								$(this).remove();
							});
					}
				}
			};

			this.flip = function() {
				var tmp = this.curSide;
				this.curSide = this.flipSide;
				this.flipSide = tmp;
			};

			this.cookedWell = function() {
				return (this.curSide > 95 && this.curSide < 105 && this.flipSide > 95 && this.flipSide < 105);
			}

			this.score = function() {
				return Math.min(this.scoreSide(this.curSide), this.scoreSide(this.flipSide));			
			};

			this.scoreSide = function(doneness) {
				if (doneness > 100) {
					doneness = 100 - (doneness - 100);
				}

				donenessRange = 100 - doneness;

				if (donenessRange <= mechanics.pattyScores.perfect.range) {
					return mechanics.pattyScores.perfect.score;
				} else if (donenessRange <= mechanics.pattyScores.great.range) {
					return mechanics.pattyScores.great.score;
				} else if (donenessRange <= mechanics.pattyScores.ok.range) {
					return mechanics.pattyScores.ok.score;
				} else if (donenessRange <= mechanics.pattyScores.bad.range) {
					return mechanics.pattyScores.bad.score;
				} else {
					return mechanics.pattyScores.danger.score;
				}
			};
		
			this.yulp = function() {
				return Math.min(this.yulpSide(this.curSide), this.yulpSide(this.flipSide));
			};

			this.yulpSide = function(doneness) {
				if (doneness > 100) {
					doneness = 100 - (doneness - 100);
				}

				donenessRange = 100 - doneness;

				if (donenessRange <= mechanics.pattyScores.perfect.range) {
					return mechanics.pattyScores.perfect.yulp;
				} else if (donenessRange <= mechanics.pattyScores.great.range) {
					return mechanics.pattyScores.great.yulp;
				} else if (donenessRange <= mechanics.pattyScores.ok.range) {
					return mechanics.pattyScores.ok.yulp;
				} else if (donenessRange <= mechanics.pattyScores.bad.range) {
					return mechanics.pattyScores.bad.yulp;
				} else {
					return mechanics.pattyScores.danger.yulp;
				}
			};
		};

      $(document).ready(function() {
			// griddle temperature controls
         $("#low").click(function() {
				griddle.turnOff();
            griddle.turnOn(mechanics.griddleTempLow);
				$(this).css("background-color", "orange");
				$("#med").css("background-color", "");
				$("#high").css("background-color", "");
				$("#off").css("background-color", "");
         });

         $("#med").click(function() {
				griddle.turnOff();
            griddle.turnOn(mechanics.griddleTempMed);
				$(this).css("background-color", "orange");
				$("#low").css("background-color", "");
				$("#high").css("background-color", "");
				$("#off").css("background-color", "");
         });

         $("#high").click(function() {
				griddle.turnOff();
            griddle.turnOn(mechanics.griddleTempHigh);
				$(this).css("background-color", "orange");
				$("#low").css("background-color", "");
				$("#med").css("background-color", "");
				$("#off").css("background-color", "");
         });

         $("#off").click(function() {
            griddle.turnOff();
				$(this).css("background-color", "orange");
				$("#low").css("background-color", "");
				$("#med").css("background-color", "");
				$("#high").css("background-color", "");
         });

			$("#pause").click(function() {
				mechanics.paused = true;

				prepTable.stopTimer();
				orderCollection.stopTimer();
				griddle.turnOff();

				window.clearTimeout(mechanics.nextOrder);

				$("[id^=patty]").draggable("disable");
				$("#low, #med, #high, #off, #fillOrder").attr("disabled", "true");
				$("#pause, #resume").toggle();
			});

			$("#resume").click(function() {
				mechanics.paused = false;

				prepTable.startTimer();
				orderCollection.startTimer();
				griddle.turnOn(griddle.cookInterval);
				$("#low, #med, #high, #off, #filLOrder").removeAttr("disabled");
				$("[id^=patty]").draggable("enable");

				mechanics.nextOrder = window.setTimeout(function() {
					var order = new Order();
					order.burgerCount = Math.floor(Math.random() * (mechanics.orderBurgerCountUpper - mechanics.orderBurgerCountLower)) + mechanics.orderBurgerCountLower;
					order.maxAge = Math.floor(Math.random() * (mechanics.orderMaxAgeUpper - mechanics.orderMaxAgeLower)) + mechanics.orderMaxAgeLower;
					orderCollection.addOrder(order);
				}, Math.floor(Math.random() * 8000) + (Math.random() * 80000) + 20000);

				$("#pause, #resume").toggle();
			});

			$("#fillOrder").click(function() {
				// get the currentOrder
				var order = orderCollection.getOrder(orderCollection.currentOrder);

				// do we have enough patties to fill the current order?
				if (order) {
					if (prepTable.patties.length >= order.burgerCount) {
						// remove the patties from the preptable
						var orderPats = [];

						for (var x = 0; x < order.burgerCount; x++) {
							orderPats.push(prepTable.removeOldestPatty());
						}

						// mark the order as filled
						orderCollection.fillOrder(orderPats);
					} 
				}
			});

			$("#griddle").click(function(e) {
				if (!mechanics.paused) {
					// create a new patty
					var patty = new Patty(e.pageY - 50, e.pageX - 50);	

					// make sure this is a valid placement before we create
					var valid = true;

					// make sure we aren't colliding with another patty
					if (griddle.patties.length > 0) {
						for (var x = 0; x < griddle.patties.length; x++) {
							if (overlaps($(griddle.patties[x].idHash).position(), {top: e.pageY - 50, left: e.pageX - 50})) {
								valid = false;
							}
						}
					}

					// check we are within the confines of the griddle
					var obj2 = $("#griddle").position();

					if (!withinBounds(
						{top: e.pageY - 50, left: e.pageX - 50}, 
						{top: obj2.top, left: obj2.left, width: $("#griddle").width(), height: $("#griddle").height()}
					)) {
						valid = false;
					}

					// add it to the griddle
					if (valid !== false) {
						griddle.addPatty(patty);
					} else {
						delete patty;

						// show the collision box
						$("<div></div>")
							.addClass("colBox")
							.css("top", e.pageY - 50 + "px")
							.css("left", e.pageX - 50 + "px")
							.css("z-index", 1500)
							.appendTo("#griddle")
							.fadeIn(200).fadeOut(200).fadeIn(200).fadeOut(200, function() { $(this).remove(); });

					}
				}
			});

			$("#griddle").on("click", ".patty", function(e) {
				if (!mechanics.paused) {
					for (var x = 0; x < griddle.patties.length; x++) {
						if (griddle.patties[x].id == $(e.target).attr("id")) {
							griddle.patties[x].flip();
							griddle.draw();

							if (griddle.griddleOn) {
								soundBuffer("patty.mp3");
							}
						}
					}

					e.stopPropagation();
				}
			});

			$("#griddle").on("mousedown", ".patty", function(e) {
				if (!mechanics.paused) {
					for (var x = 0; x < griddle.patties.length; x++) {
						if (griddle.patties[x].id == $(e.target).attr("id")) {
							if (griddle.patties[x].dying === true) {
								$(griddle.patties[x].idHash).stop(true, true);
								$(griddle.patties[x].idHash).fadeIn(1);
								griddle.patties[x].dying = false;	
							} else {
								griddle.patties[x].cookable = false;
							}
						}
					}
				}
			});

			$("#griddle").on("mouseup", ".patty", function(e) {
				if (!mechanics.paused) {
					for (var x = 0; x < griddle.patties.length; x++) {
						if (griddle.patties[x].id == $(e.target).attr("id")) {
							griddle.patties[x].cookable = true;
						}
					}
				}
			});

			$(".patty").mouseout(function(e) {
				if (!mechanics.paused) {
					for (var x = 0; x < griddle.patties.length; x++) {
						if (griddle.patties[x].id == $(e.target).attr("id")) {
							griddle.patties[x].cookable = true;
						}
					}
				}
			});

			$("#griddle").droppable({
				 tolerance: 'fit'
			});

			$("#preptable").droppable({
				tolerance: "fit",
				drop: function(e, ui) {
					// check the doneness values
					for (var x = 0; x < griddle.patties.length; x++) {
						var patty = griddle.patties[x];

						if (griddle.patties[x].id == ui.draggable.attr("id")) {
							if (griddle.patties[x].cookedWell()) {
								$("#" + ui.draggable.attr("id")).html("<img src='thumbsup.png' />");
							} else {
								$("#" + ui.draggable.attr("id")).html("<img src='thumbsdown.png' />");
							}

							player.scoreBoard.draw();

							$("#" + ui.draggable.attr("id")).fadeOut(200).fadeIn(200).fadeOut(200).fadeIn(200).delay(500).fadeOut(200, function() { 
								prepTable.addPatty(griddle.removePatty(ui.draggable.attr("id")));
								$(this).remove();
							});
						}
					}
				}
			});

			$("#floor").droppable({
				tolerance: "fit",
				drop: function(e, ui) {
					griddle.removePatty(ui.draggable.attr("id"));
					$("#" + ui.draggable.attr("id")).remove();
					player.scoreBoard.garbage++;
					player.scoreBoard.draw();
				}
			});

			mechanics.nextOrder = window.setTimeout(function() {
				var order = new Order();
				order.burgerCount = Math.floor(Math.random() * (mechanics.orderBurgerCountUpper - mechanics.orderBurgerCountLower)) + mechanics.orderBurgerCountLower;
				order.maxAge = Math.floor(Math.random() * (mechanics.orderMaxAgeUpper - mechanics.orderMaxAgeLower)) + mechanics.orderMaxAgeLower;
				orderCollection.addOrder(order);
			}, Math.floor(Math.random() * 8000) + 1000);
		});
		</script>
	</head>
	<body>
		<div id='ovencontrols'>
			<button id='off' style='background-color: orange;'>Off</button>
			<button id='low'>Low</button>
			<button id='med'>Med</button>
			<button id='high'>High</button>
			<button id='pause'>Pause Game</button>
			<button style='display: none;' id='resume'>Resume Game</button>
		</div>
		<div id='scoreBox'>Score: <span id='curScore'>0</span></div>
		<div id='workspace'>
			<div id='griddle'>
			</div>
			<div id='preptable'>
				<button id='fillOrder'>Fill Order</button>
			</div>
			<div id='floor'>
			</div>
		</div>
		<div id='adminSpace'>
			<div id='currentOrder'>
				Order #<span class='orderNumber'>-</span>
				Burgers: <span class='burgerCount'>-</span>
				Age: <span class='orderAge'>-</span>
				<div id='currentOrderBG'></div>
			</div>
			<div id='orderCollection'>
				Total Orders: <span class='totalOrders'>0</span>
				Burgers All Day: <span class='burgersAllDay'>0</span>	
				Orders Filled: <span class='ordersFilled'>0</span>
			</div>
			<div id='instructions'>
				<p>Welcome to Burger Bus... a new project by fdask.</p>
				<p>The goal here is to simulate cooking some burgers on a flat top!</p>
				<p>On the left there, you have three areas... a griddle (upper left), a prep table (upper right), and the floor (bottom).</p>
				<p>To get started, click anywhere on the griddle to slap down a new patty.  Then turn on the griddle using the button at the top left.</p>
				<p>As the patty cooks, you will see the % in the upper right corner increase.  Once the doneness of the patty approaches 100%, click it to flip it over and start cooking the other side.</p>
				<p>When both sides are as close to 100% as you can get them, drag the patty over on to the prep area on the right.  You will get either a thumbs up or a thumbs down depending on how well the patty has been cooked.</p>
				<p>If you accidentally burn a burger, you can discard it by dragging it to the floor area below the griddle.</p>
				<p>Good luck and happy cooking!</p>
			</div>
			<div id='scoreBoard' style='display: none;'>
				Good Burgers: <span class='good'>0</span>
				Bad Burgers: <span class='bad'>0</span>
				Garbage: <span class='garbage'>0</span>
			</div>
		</div>
	</body>
</html>
