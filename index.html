<html>
	<head>
		<title>Burger Bus</title>
		<link href="style.css" type="text/css" rel="stylesheet" />
		<script src='burger.js'></script>
      <script src='//code.jquery.com/jquery-1.10.2.js'></script>
		<script src='//code.jquery.com/ui/1.10.3/jquery-ui.js'></script>
		<script>
		// Google Plus functions
		function signinCallback(authResult) {
			if (authResult['access_token']) {
				// Successfully authorized
				// Hide the sign-in button now that the user is authorized, for example:
				player.tokenGPlus = authResult['access_token'];

				$('#signinButton').setAttribute('style', 'display: none');

				console.log("signin successful!");

				gapi.client.load('plus','v1', function(){
					var request = gapi.client.plus.people.get({ 'userId': 'me' });
			
					request.execute(function(resp) {
						player.name = resp.displayName;

						$("#loginsBox").html("Welcome, " + player.name + "! (<a href='#' onclick='disconnectUser(player.tokenGPlus); return false;'>Logout</a>)");
					});
				});
			} else if (authResult['error']) {
				// There was an error.
				// Possible error codes:
				//   "access_denied" - User denied access to your app
				//   "immediate_failed" - Could not automatically log in the user
				console.log('There was an error: ' + authResult['error']);
			}
		}

		function disconnectUser(access_token) {
			var revokeUrl = 'https://accounts.google.com/o/oauth2/revoke?token=' + access_token;

			// Perform an asynchronous GET request.
			$.ajax({
				type: 'GET',
				url: revokeUrl,
				async: false,
				contentType: "application/json",
				dataType: 'jsonp',
				success: function(nullResponse) {
					// Do something now that user is disconnected
					// The response is always undefined.
					console.log("Successfully logged out of Google+");
				},
				error: function(e) {
					// Handle the error
					// console.log(e);
					// You could point users to manually disconnect if unsuccessful
					// https://plus.google.com/apps
					console.log("There was an error logging out of Google+");
				}
			});
		}

		var mechanics = new function() {
			this.nextOrder = null;
		
			this.dailyPatties = 30;

			// how long to wait before first order comes in
			this.initialOrderDelayLower = 8000;
			this.initialOrderDelayUpper = 10000;

			// how often orders come in (in milliseconds)
			this.orderFrequencyLower = 20000;
			this.orderFrequencyUpper = 100000;

			// values in seconds indicating how long a customer will wait for an order (until it expires)
			this.orderMaxAgeUpper = 180; // maximum for order wait time
			this.orderMaxAgeLower = 180; // minimum value for random order wait time

			this.orderBurgerCountUpper = 3; // maximum number of burgers per order
			this.orderBurgerCountLower = 1; // least number of burgers per order

			this.paused = false; // system wide pause setting

			this.prepTableLevel = 0;

			this.prepTableSlots = {
				0: 3,
				1: 5,
				2: 8,
				3: 10
			};

			this.maxPattiesOnPrep = this.prepTableSlots[3]; // maximum number of patties on the prep table at once
			this.prepTableExpire = 120; // number of seconds a patty lives on the prep table

			// ms for each cook() iteration at diff oven temps
			// goes up to 4!
			this.griddleLevel = 0;

			this.griddleSizes = {
				0 : {
					width: 250,
					height: 230
				},
				1 : {
					width: 370,
					height: 230
				},
				2 : {
					width: 370,
					height: 350
				},
				3 : {
					width: 500,
					height: 350
				}
			};

			this.griddleTempHigh = 300; 
			this.griddleTempMed = 800;
			this.griddleTempLow = 1500;

			this.pattyMaxDone = 120; // max doneness of a side before we blink out
			this.pattyBeefQuality = 1; // a multiplier on the score indicating beef quality
			this.pattyMaxFlips = 2 + this.pattyBeefQuality; // number of flips before a patty disentegrates
			this.pattyBurnNegChance = 10;
			this.fireGrowInterval = 2000; // number of ms between each fire grow
			this.fireGrowSize = 20; // number of px a fire grows on each side
         this.fireEndDelay = 10000; // how long a fire burns once it's filled up the griddle
			this.fireDebug = false;
			this.fireCount = 0;

			this.crudShrinkInterval = 10000; // ms between each shrink of crud
			this.crudShrinkSize = 5; // number of pixels on each side the crud shrinks
			this.crudDebug = false;
			this.crudCount = 0;

			// scoring
			this.tipAmountMultiplier = 1; // basically the level of tips you receive
			this.tipAmountPercentageLower = 2;
			this.tipAmountPercentageUpper = 30;

			this.dragDebug = false;
			this.placementDebug = false;
			this.orderDebug = false;
			this.scoringDebug = false;
			this.tipDebug = false;

			this.orderSpeedBonus = {
				percent: 10,
				bonus: 10
			};

			this.orderSpeedBonusPrint = function(prefix) {
				prefix = typeof prefix !== 'undefined' ? prefix : "";

				console.log(prefix + "Order speed bonus of +" . this.orderSpeedBonus.bonus + "% applies if order filled within first " + this.orderSpeedBonus.percent + "% of order life.");
			};

			this.pattyScores = {
				danger: {
					score: 0,
					range: 25,
					yulp: 1
				},
				bad: {
					score: 0,
					range: 20,
					yulp: 2
				},
				ok: {
					score: 10,
					range: 15,
					yulp: 3
				},
				great: {
					score: 20,
					range: 8,
					yulp: 4
				},
				perfect: {
					score: 50,
					range: 0,
					yulp: 5
				}
			};		

			this.pattyScoresPrint = function(prefix) {
				prefix = typeof prefix !== 'undefined' ? prefix : "";

				console.log(prefix + "Burger Scoring Chart");
				console.log(prefix + "PERFECT: 100 to " + (100 - this.pattyScores.perfect.range));
				console.log(prefix + "GREAT: " + ((100 - this.pattyScores.perfect.range) - 1) + " to " + (100 - this.pattyScores.great.range));
				console.log(prefix + "OK: " + ((100 - this.pattyScores.great.range) - 1) + " to " + (100 - this.pattyScores.ok.range));
				console.log(prefix + "BAD: " + ((100 - this.pattyScores.ok.range) - 1) + " to " + (100 - this.pattyScores.bad.range));
				console.log(prefix + "DANGER: " + ((100 - this.pattyScores.bad.range) - 1) + " to 0");
			}

			this.heatModifiers = {
				sizzling: {
					range: 20,
					subtract: 0
				},
				warm: {
					range: 50,
					subtract: 10
				},
				cold: {
					range: 75,
					subtract: 40
				},
				stale: {
					subtract: 80 
				} 
			}

			this.heatModifiersPrint = function(prefix) {
				prefix = typeof prefix !== 'undefined' ? prefix : "";

				console.log(prefix + "HeatModifier Scale:");
				console.log(prefix + "SIZZLING: 100 to " + (100 - this.heatModifiers.sizzling.range));
				console.log(prefix + "WARM: " + ((100 - this.heatModifiers.sizzling.range) - 1) + " to " + (100 - this.heatModifiers.warm.range));
				console.log(prefix + "COLD: " + ((100 - this.heatModifiers.warm.range) - 1) + " to " + (100 - this.heatModifiers.cold.range));
				console.log("STALE: " + ((100 - this.heatModifiers.cold.range) - 1) + " to 0");
			};

			// percentage of time an order will be for a yulp reviewer
			this.yulpFrequency = 1;

			// a popularity modifier that factors in to the scoring!
			this.popularity = 1;

			this.pause = function() {
				this.paused = true;

				prepTable.stopTimer();
				orderCollection.stopTimer();
				griddle.turnOff();

				window.clearTimeout(this.nextOrder);

				$("[id^=patty]").draggable("disable");
				$("#low, #med, #high, #off, #fillOrder").attr("disabled", "true");
				$("#pause, #resume").toggle();
			};

			this.resume = function() {
				if (this.paused) {
					this.paused = false;

					prepTable.startTimer();
					orderCollection.startTimer();

					if (griddle.cookInterval > 0) {
						griddle.turnOn(griddle.cookInterval);
					}

					$("#low, #med, #high, #off, #filLOrder").removeAttr("disabled");
					$("[id^=patty]").draggable("enable");

					this.nextOrder = window.setTimeout(function() {
						var order = new Order();
						var val = Math.floor(Math.random() * (this.orderBurgerCountUpper - this.orderBurgerCountLower)) + this.orderBurgerCountLower;

						if (mechanics.orderDebug) {
							console.log("Math.floor(Math.random() * (" + mechanics.orderBurgerCountUpper + " - " + mechanics.orderBurgerCountLower + ")) + " + mechanics.orderBurgerCountLower + " = " + val);
						}

						order.burgerCount = val;
						order.maxAge = Math.floor(Math.random() * (this.orderMaxAgeUpper - this.orderMaxAgeLower)) + this.orderMaxAgeLower;
						orderCollection.addOrder(order);
					}, Math.floor(Math.random() * (mechanics.orderFrequencyUpper - mechanics.orderFrequencyLower)) + mechanics.orderFrequencyLower);

					$("#pause, #resume").toggle();
				}
			};

			this.popUpDefaults = {
				autoOpen: false,
				closeOnEscape: true,
				dialogClass: 'popUp',
				draggable: false,
				modal: true,
				resizable: false,
				height: 500,
				width: 800,	
				maxHeight: 500,
				position: {
					my: 'center top', 
					at: 'center top', 
					of: window
				},
				open: function(e, ui) {
					mechanics.pause();
				},
				close: function(e, ui) {
					mechanics.resume();
				}
			};

			this.buffs = {
				fireExtinguisher: {
					price: 50,
					id: 'buffFireExtinguisher',
					click: function() {
						if (mechanics.fireDebug) {
							console.log("using an extinguisher to remove all fires!");
						}

						for (var x = 0; x < griddle.fires.length; x++) {
							griddle.fires[x].destroy();
						}

						player.buffs.fireExtinguisher.count--;

						mechanics.updateBuffs();
					}
				},
				microwave: {
					price: 50,
					id: 'buffMicrowave'
				},
				scraper: {
					price: 50,
					id: 'buffScraper',
					click: function() {
						// remove all crud
						if (mechanics.crudDebug) {
							console.log("Using scraper to remove all crud!");
						}

						for (var x = 0; x < griddle.crud.length; x++) {
							griddle.removeCrud(griddle.crud[x].id);
						}

						player.buffs.scraper.count--;

						mechanics.updateBuffs();
					}
				},
				pause: {
					price: 50,
					id: 'buffPause'
				},
				heatLamp: {
					price: 50,
					id: 'buffHeatLamp'
				},
				twitter: {
					price: 50,
					id: 'buffTwitter'
				},
				sauce: {
					price: 50,
					id: 'buffSauce'
				},
				helper: {
					price: 50,
					id: 'buffHelper'
				}
			};

			this.updateBuffs = function() {
				var keys = Object.keys(this.buffs);

				for (var x = 0; x < keys.length; x++) {
					$("#" + this.buffs[keys[x]].id + "Count").html(player.buffs[keys[x]].count);

					if (player.buffs[keys[x]].count > 0) {
						$("#" + this.buffs[keys[x]].id)
							.css("background-image", "url('images/" + keys[x] + "_on.png')")
							.off("click")
							.on("click", this.buffs[keys[x]].click);
					} else {
						if (player.buffs[keys[x]].count < 0) {
							player.buffs[keys[x]].count = 0;
						}

						$("#" + this.buffs[keys[x]].id)
							.css("background-image", "url('images/" + keys[x] + "_off.png')")
							.off("click");
					}
				}	
			};
		};

		var prepTable = new function() {
			this.patties = [];
			this.pattyCount = 0;
			this.timer = null;

			this.addPatty = function(patty) {
				if (this.patties.length < mechanics.prepTableSlots[mechanics.prepTableLevel]) {
					var newId = this.pattyCount;
					this.pattyCount++;
					patty.id = "prep" + newId;
					patty.idHash = "#" + patty.id;
					patty.max = mechanics.prepTableExpire;
					patty.remain = patty.max;
					this.patties.push(patty);

					// determine a color for the heat bar
					if (patty.cookedWell()) {
						patty.color = "#a3f141";
					} else {
						patty.color = "red";
					}

					this.draw();

					if (!mechanics.paused) {
						this.startTimer();
					}
				} 
			};

			this.getPatty = function(id) {
				for (var x = 0; x < this.patties.length; x++) {
					if (this.patties[x].id == id) {
						return this.patties[x];
					}
				}

				return false;
			};

			this.getOldestPatty = function() {
				var curTime = 0;
				var curId = "";

				for (var x = 0; x < this.patties.length; x++) {
					var secsOld = this.patties[x].max - this.patties[x].remain;

					if (curTime == 0) {
						curTime = secsOld;
						curId = this.patties[x].id;
					} else if (secsOld > curTime) {
						curTime = secsOld;
						curId = this.patties[x].id;
					}
				}

				return this.getPatty(curId);
			}

			this.removePatty = function(id) {
				if (id) {
					var ret = null;

					// remove a specific patty from the array
					var tmp = [];

					for (var x = 0; x < this.patties.length; x++) {
						if (this.patties[x].id != id) {
							tmp.push(this.patties[x]);
						} else {
							ret = this.patties[x];
						}
					}

					this.patties = tmp;
				} 
			
				$("#" + id).prev().toggle();
				$("#" + id).remove();

				if (this.patties.length === 0) {
					this.stopTimer();
				}

				this.draw(true);	

				if (this.patties.length < mechanics.prepTableSlots[mechanics.prepTableLevel]) {
					$("#preptable").droppable("enable");
				}

				return ret;
			};

			this.removeOldestPatty = function() {
				return this.removePatty(this.getOldestPatty().id);
			};

			this.startTimer = function() {
				if (this.timer === null) {
					this.timer = window.setInterval(bindMe(this, this.decRemain), 1000);
				}
			};

			this.decRemain = function() {
				for (var x = 0; x < this.patties.length; x++) {
					if (this.patties[x].remain > 0) {
						this.patties[x].remain--;
					} else {
						this.removePatty(this.patties[x].id);
					}
				}

				this.draw();
			};

			this.stopTimer = function() {
				if (this.timer !== null) {
					clearInterval(this.timer);
				}

				this.timer = null;
			}

			this.draw = function(refresh) {
				if (refresh) {
					$("#preptable>[id^=slot], #preptable>.prepPatty").remove();
				}

				// first we draw all the slots as hidden
				if (this.patties.length < mechanics.prepTableSlots[mechanics.prepTableLevel]) {
					for (var x = 0; x < (mechanics.prepTableSlots[mechanics.prepTableLevel]); x++) {
						if (!$("#slot" + x).length) {
							$("<div>Slot #" + (x + 1) + "</div>")
								.addClass("prepPatty")	
								.css("display", "")
								.attr("id", "slot" + x)
								.appendTo("#preptable");
						}
					}
				}

				// now we draw the unusable prepTable slots
				for (; x < mechanics.maxPattiesOnPrep; x++) {
					if (!$("#slot" + x).length) {
						$("<div>Slot #" + (x + 1) + "</div>")
							.addClass("prepPatty prepTableSlotFill")	
							.css("display", "")
							.attr("id", "slot" + x)
							.appendTo("#preptable");
					}
				}

				// now go through any patties, either drawing, or updating!
				for (var x = 0; x < this.patties.length; x++) {
					if ($(this.patties[x].idHash).length > 0) {
						// update the patty div on preptable
						var pb = progressBar(this.patties[x].remain, this.patties[x].max, $("#preptable").width());

						$(this.patties[x].idHash + " .progressBar")
							.css("width", pb.fillWidth)
							.html(pb.percent + "%");
					} else {
						// draw the patty div on preptable
						var pb = progressBar(this.patties[x].remain, this.patties[x].max, $("#preptable").width());

						var pattyId = this.patties[x].id;

						var addEl = $("<div></div>")
                        .attr("id", this.patties[x].id)
                        .addClass("prepPatty")
                        .append("<div class='progressBar' style='height: 100%; background-color: " + this.patties[x].color + "; width: " + pb.fillWidth + "px;'>" + pb.percent + "%</div>")
                        .append($("<div class='garbageIcon'><img src='images/trash.png' height='28' /></div>").click(function(e) {
                           player.garbage++;
                           prepTable.removePatty(pattyId);
                        }));

						$("#slot" + x).after(addEl).toggle();	
					}
				}
			};
		};

		var Order = function() {
			this.number = 0;
			this.burgerCount = 0;
			this.age = 0;
			this.maxAge = 0;
			this.filled = false;
			this.result = "";

			this.draw = function() {
				$("#currentOrder .orderNumber").html(this.number);
				$("#currentOrder .burgerCount").html(this.burgerCount);
				$("#currentOrder .orderAge").html(getTime(this.age));
			};
		};

		var orderCollection = new function() {
			this.orders = [];
			this.orderCounter = 0;
			this.currentOrder = "";
			this.timer = null;

			this.startTimer = function() {
				if (this.timer === null) {
					this.timer = window.setInterval(bindMe(orderCollection, orderCollection.ageOrders), 1000);
				}
			};

			this.stopTimer = function() {
				if (this.timer !== null) {
					clearInterval(this.timer);
				}

				this.timer = null;
			};

			this.ageOrders = function() {
				for (var x = 0; x < this.orders.length; x++) {
					this.orders[x].age++;

					// checking for expiring orders here
					var expiring = false;

					if (this.orders[x].age > this.orders[x].maxAge & !this.orders[x].filled) {
						if (this.orders[x].number == this.currentOrder) {
							this.currentOrder = "";
						}

						$("#currentOrderBG").fadeIn(200).fadeOut(200).fadeIn(200).fadeOut(200).fadeIn(200).fadeOut(200, function() { 
							soundBuffer("sounds/boo.mp3");
							orderCollection.draw(); 
						});

						this.removeOrder(this.orders[x].number);
						expiring = true;
					}
				}

				if (!expiring) {
					this.draw();
				}
			};

			this.draw = function() {
				$("#orderCollection .totalOrders").html(this.orderCount());
				$("#orderCollection .burgersAllDay").html(this.burgerTotal());
				$("#orderCollection .ordersFilled").html(this.ordersFilled());

				if (this.currentOrder == "") {
					var tmp = this.getOldest();

					if (tmp) {
						this.currentOrder = tmp.number;
					} else {
						$("#currentOrder .orderNumber").html("-");
						$("#currentOrder .burgerCount").html("-");
						$("#currentOrder .orderAge").html("-");
					}
				}

				// draw the order if there is one
				if (this.currentOrder != "") {
					this.getOrder(this.currentOrder).draw();
				}	
			};

			this.orderCount = function() {
				var ret = 0;

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].filled === false) {
						ret++;
					}
				}

				return ret;
			}

			this.ordersFilled = function() {
				var ret = 0;

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].filled) {
						ret++;
					}
				}

				return ret;
			};

			this.burgerTotal = function() {
				var ret = 0;

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].filled === false) {
						ret += this.orders[x].burgerCount;					
					}
				}

				return ret;
			}

			this.addOrder = function(order) {
				// make sure this order is possible with the number of patties remaining
				if (mechanics.orderDebug) {
					console.log("Griddle patty count: " + griddle.patties.length);
					console.log("Preptable patty count: " + prepTable.patties.length);
					console.log("Unused patty count: " + mechanics.dailyPatties);
					console.log("Burgers all day: " + orderCollection.burgerTotal());
				}

				var burgersLeft = griddle.patties.length + prepTable.patties.length + mechanics.dailyPatties - orderCollection.burgerTotal();

				if (mechanics.orderDebug) {
					console.log("We have " + burgersLeft + " burgers left.  Order is for " + order.burgerCount);
				}

				if (order.burgerCount > burgersLeft) {
					if (mechanics.orderDebug) {
						console.log("Reducing order burgerCount to " + burgersLeft);
					}

					order.burgerCount = burgersLeft;
				}

				if (order.burgerCount <= 0) {
					if (mechanics.orderDebug) {
						console.log("No patties left to fill order!  No new orders scheduled.");
					}

					return;
	 			}	

				// generate an order number
				order.number = ++this.orderCounter;

				// add to the orders array
				this.orders.push(order);

				// start the timer if its not already
				if (this.timer === null) {
					this.startTimer();
				}

				this.draw();

				soundBuffer("sounds/bell.mp3");

				if (!mechanics.paused) {
					mechanics.nextOrder = window.setTimeout(function() {
						var order = new Order();
						var val = Math.floor(Math.random() * (mechanics.orderBurgerCountUpper - mechanics.orderBurgerCountLower)) + mechanics.orderBurgerCountLower;
	
						if (mechanics.orderDebug) {
							console.log("Math.floor(Math.random() * (" + mechanics.orderBurgerCountUpper + " - " + mechanics.orderBurgerCountLower + ")) + " + mechanics.orderBurgerCountLower + " = " + val);
						}

						order.burgerCount = val;
						order.maxAge = Math.floor(Math.random() * (mechanics.orderMaxAgeUpper - mechanics.orderMaxAgeLower)) + mechanics.orderMaxAgeLower;
						orderCollection.addOrder(order);
					}, Math.floor(Math.random() * (mechanics.orderFrequencyUpper - mechanics.orderFrequencyLower)) + mechanics.orderFrequencyLower);
				}
			};
		
			this.removeOrder = function(number) {
				// remove order identified by the order#
				var tmp = [];

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].number != number) {
						tmp.push(this.orders[x]);
					}			
				}

				this.orders = tmp;
			};

			this.getOrder = function(number) {
				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].number == number) {
						return this.orders[x];
					}
				}
			};

			this.getOldest = function() {
				var orderNum = "";
				var orderTime = 0;

				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].filled === false) {
						if (orderTime == 0) {
							orderTime = this.orders[x].age;
							orderNum = this.orders[x].number;
						} else {
							if (this.orders[x].age < orderTime) {
								orderTime = this.orders[x].age;
								orderNum = this.orders[x].number;
							}
						}
					}
				}

				if (orderNum != "") {
					return this.getOrder(orderNum);	
				} else {
					return false;
				}
			};

			this.fillOrder = function(patties) {
				// clean up the order
				for (var x = 0; x < this.orders.length; x++) {
					if (this.orders[x].number == this.currentOrder) {
						var age = this.orders[x].age;
						var maxAge = this.orders[x].maxAge;

						this.orders[x].filled = true;
						this.currentOrder = "";
						this.draw();

						soundBuffer("sounds/orderup.mp3");

						break;
					}
				}

				// compute the score
				var score = 0;
				var yulp = [];

				if (mechanics.scoringDebug) {
					console.log("SCORING");
					mechanics.pattyScoresPrint();
					mechanics.heatModifiersPrint();
					mechanics.orderSpeedBonusPrint();

					console.log("((Burger Score * Heat Modifier) * Beef Quality) * Popularity Modifier");
					console.log("********************");
				}
				
				for (var x = 0; x < patties.length; x++) {
					score += patties[x].score();
				
					yulp.push(patties[x].yulp());
				}

				// order speed bonus
				var orderPercent = ((maxAge - age) / maxAge) * 100;

				if (orderPercent > (100 - mechanics.orderSpeedBonus.percent)) {
					if (mechanics.scoringDebug) {
						console.log("Speed Bonus: " + Math.floor((score * (mechanics.orderSpeedBonus.bonus / 100))));
					}

					score += Math.floor((score * (mechanics.orderSpeedBonus.bonus	/ 100)));

					// always gets a tip if the order is fulfilled quickly
					var tipPercentage = Math.floor((Math.random() * (mechanics.tipAmountPercentageUpper - mechanics.tipAmountPercentageLower)) + mechanics.tipAmountPercentageLower);

					var tip = (score * (tipPercentage)) * mechanics.tipAmountMultiplier;

					if (mechanics.tipDebug) {
						console.log("Random tip percentage between " + mechanics.tipAmountPercentageLower + " and " + mechanics.tipAmountPercentageUpper + ": " + tipPercentage + "%");
						console.log(score + " * " + (tipPercentage) + " * " + mechanics.tipAmountMultiplier + " = " + tip);
					}

					if (tip > 0) {
						player.addTip(tip);
					}
				}

				var tmp = Math.min.apply(0, yulp);

				if (mechanics.scoringDebug) {
					console.log("Total: " + score);
					console.log("\n");
				}

				player.addScore(score);

				// if this is a yulp reviewer, add the review!
				if ((Math.floor(Math.random() * 100) + 1) <= mechanics.yulpFrequency) {
					player.yulps.push(tmp);
				}

			};
		};

		var player = new function() {
			// access token when signed in with Google+
			this.tokenGPlus = "";

			this.name = "";
			this.score = 0;
			this.tips = 0;
			this.yulps = [];

			this.good = 0;
			this.bad = 0;
			this.garbage = 0;
			this.griddleTimeout = 0;
			this.prepTableTimeout = 0;
			this.servedCustomers = 0;
			this.satisfiedCustomers = 0;
			this.unsatisfiedCustomers = 0;

			// buffs
			this.buffs = {
				fireExtinguisher: {
					count: 0
				},
				microwave: {
					count: 0
				},
				scraper: {
					count: 0
				},
				pause: {
					count: 0
				},
				heatLamp: {
					count: 0
				},
				twitter: {
					count: 0
				},
				sauce: {
					count: 0
				},
				helper: {
					count: 0
				}
			};

			this.addScore = function(value) {
				this.score += value;

				$("<span id='addScore'>+" + value + "</span>")
					.appendTo("#scoreBox")
					.fadeIn(200)
					.fadeOut(200)
					.fadeIn(200)
					.fadeOut(200)
					.fadeIn(200)
					.fadeOut(200, function() {
						$("#curScore").html(player.score);
						$(this).remove();
					});
			};

			this.addTip = function(value) {
				this.tips += value;

				$("<span id='addTip'>+$" + formatDollars(value) + "</span>")
					.appendTo("#tipBox")
					.fadeIn(200)
					.fadeOut(200)
					.fadeIn(200)
					.fadeOut(200)
					.fadeIn(200)
					.fadeOut(200, function() {
						$("#curTips").html(formatDollars(player.tips));
						$(this).remove();
					});
			};

			this.removeTip = function(value) {
				this.tips -= value;

				if (this.tips < 0) {
					this.tips = 0;
				}

				$("#curTips").html(formatDollars(this.tips));
			};
		};

		var griddle = new function() {
			this.patties = [];
			this.fires = [];
			this.crud = [];
			this.griddleOn = false;
			this.timer = null;
			this.cookInterval = 0;
			this.pattyCount = 0;

			this.getPattyID = function() {
				var ret = this.pattyCount;

				this.pattyCount++;

				return ret;
			};

			this.turnOn = function(interval) { 
            if (this.timer !== null) {
					clearInterval(this.timer);
				} else {
					if (this.patties.length > 0) {
						soundBuffer("sounds/patty.mp3");
					}
				}

				this.timer = window.setInterval(bindMe(griddle, griddle.cook), interval);
				this.griddleOn = true;
				this.cookInterval = interval;

				// start back up the timers on any fire or crud
				for (var x = 0; x < this.crud.length; x++) {
					this.crud[x].startTimer();
				}

				for (var x = 0; x < this.fires.length; x++) {
					this.fires[x].startTimer();
				}
			};

			this.turnOff = function() {
				if (this.timer != null) {
					clearInterval(this.timer);
				}

				this.timer = null;
				this.griddleOn = false;

				// stop any crud or fire timers
				for (var x = 0; x < this.crud.length; x++) {
					this.crud[x].stopTimer();
				}

				for (var x = 0; x < this.fires.length; x++) {
					this.fires[x].stopTimer();
				}
			};

			this.cook = function() {
				if (this.patties.length > 0) {
					for (var x = 0; x < this.patties.length; x++) {
						this.patties[x].cook();
					}
				} 

				this.draw();
			};

			this.addCrud = function(left, top) {
				var crud = new Crud(left, top);
				crud.id = "crud" + mechanics.crudCount;
				crud.idHash = "#" + crud.id;

				if (mechanics.crudDebug) {
					console.log("Adding crud to griddle with an id of " + crud.id);
				}

				mechanics.crudCount++;

				crud.draw();
				crud.startTimer();
				this.crud.push(crud);
			};
	
			this.removeCrud = function(id) {
				var ret = [];

				for (var x = 0; x < this.crud.length; x++) {
					if (this.crud[x].id != id) {
						ret.push(this.crud[x]);
					} else {
						this.crud[x].destroy();
					}
				}

				this.crud = ret;
			};

			this.addFire = function(left, top) {
				var fire = new Fire(left, top);
				fire.id = "fire" + mechanics.fireCount;
				fire.idHash = "#" + fire.id;
				mechanics.fireCount++;
				fire.draw();
				fire.startTimer();
				this.fires.push(fire);
			};

			this.removeFire = function(id) {
				var ret = [];

				for (var x = 0; x < this.fires.length; x++) {
					if (this.fires[x].id != id) {
						ret.push(this.fires[x]);
					}
				}

				this.fires = ret;
			};

			this.addPatty = function(patty) {
				// update the leaderboard daily burger count
				mechanics.dailyPatties--;
				$("#curBurgers").html(mechanics.dailyPatties);

				// get a unique id for this patty
				var id = this.getPattyID();
				patty.id = "patty" + id;
				patty.idHash = "#patty" + id;

				// add the patty to the griddle patty array
				this.patties.push(patty);

				// draw the patty
				this.draw();

				// if the grill is on, play the patty noise!
				if (this.griddleOn) {
					soundBuffer("sounds/patty.mp3");
				}
			};

			this.removePatty = function(id) {
				var ret = null;
				var patties = [];

				for (var x = 0; x < this.patties.length; x++) {
					if (this.patties[x].id != id) {
						patties.push(this.patties[x]);
					} else {
						ret = this.patties[x];
					}
				}

				this.patties = patties;

				this.draw();

				return ret;
			};

			this.draw = function() {
				// check to make sure the griddle is drawn the right size, according to its level!
				var gWidth = $("#griddle").width();
				var gHeight = $("#griddle").height();

				if (gWidth != mechanics.griddleSizes[mechanics.griddleLevel].width || gHeight != mechanics.griddleSizes[mechanics.griddleLevel].height) {
					$("#griddle").css("width", mechanics.griddleSizes[mechanics.griddleLevel].width + "px");
					$("#griddle").css("height", mechanics.griddleSizes[mechanics.griddleLevel].height + "px");
				}
				
				// if we have patties to draw
				if (this.patties.length > 0) {
					for (var x = 0; x < this.patties.length; x++) {
						// if the patty has already been drawn, refresh it's content
						if ($(this.patties[x].idHash).length > 0) {
							$(this.patties[x].idHash).html("<span class='curside'>" + this.patties[x].curSide + "%</span><span class='flipside'>" + this.patties[x].flipSide + "%</span>");
							var step = Math.floor(this.patties[x].flipSide / 10);

							if (step > 10) {
								$(this.patties[x].idHash).css("background-color", "black");	
							} else {
								$(this.patties[x].idHash).css("background-color", colorGradient("#FF0000", "#570A0A", step, 10));
							}
						// otherwise, draw it new
						} else {
							$("<div><span class='curside'>" + this.patties[x].curSide + "%</span><span class='flipside'>" + this.patties[x].flipSide + "%</span></div>")
								.attr("id", this.patties[x].id)
								.css("top", this.patties[x].posTop + "px")
								.css("left", this.patties[x].posLeft + "px")
								.css("background-color", "#FF0000")
								.addClass('patty')
								.draggable({
									stack: "div",
									containment: "#workspace",
									revert: function(droppableObj) {
										if (mechanics.dragDebug) {
											console.log("in the revert method");
										}

     									if (droppableObj === false) {
											soundBuffer("sounds/error.mp3");
        									return true;
     									} else {
        									return false;
     									}
									},
									stop: function(e, ui) {
										$("#" + this.id).draggable('option', 'revert', function(droppableObj) {
											if (mechanics.dragDebug) {
												console.log("in the revert method");
											}

											if (droppableObj === false) {
												soundBuffer("sounds/error.mp3");
												return true;
											} else {
												return false;
											}
										});

										if (mechanics.dragDebug) {
											console.log("in the stop method!");
										}

										if (!mechanics.paused) {
											// this is to avoid a bug where you can mouseout of the patty
											// and the mouseup never registers
											for (var x = 0; x < griddle.patties.length; x++) {
												if (griddle.patties[x].id == $(this).attr("id")) {
													if (e.toElement.id != "preptable" && e.toElement.id.match("slot") == -1 && $(e.toElement).attr("class") != "prepPatty") {
														griddle.patties[x].cookable = true;
													}
												}
											}
										}
									}
								})
								.droppable({
									greedy: true,
									tolerance: 'touch',
									drop: function(event, ui) {
										if (mechanics.dragDebug) {
											console.log("in the droppable drop!");
										}

										soundBuffer("sounds/error.mp3");
										ui.draggable.draggable('option', 'revert', true);
									}
								})
								.css("position", "absolute")
								.appendTo('#griddle');
						}

						if (this.patties[x].flips == (mechanics.pattyMaxFlips - 1)) {
							// generated at http://www.patternify.com
							$(this.patties[x].idHash).css("background-image", "url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAG0lEQVQIW2P8DwSMQMAABWAGsiBcBkUFjAOiAbjdCAX194QZAAAAAElFTkSuQmCC')");
						}
					}
				}
			}
		};

		var Crud = function(startX, startY) {
			this.id = "";
			this.idHash = "";
			this.timer = null;

			this.draw = function() {
				if (mechanics.crudDebug) {
					console.log("In the crud .draw(): " + this.id);
				}

				// create a 1x1 div at the X and Y
				$("<div></div>")
					.attr("id", this.id)
					.addClass("crudBox")
					.css("width", 100)
					.css("height", 100)
					.css("top", startY)
					.css("left", startX)
					.droppable({
						greedy: true,
						tolerance: 'touch',
						drop: function(event, ui) {
							if (mechanics.dragDebug) {
								console.log("in the crud droppable drop!");
							}

							soundBuffer("sounds/error.mp3");
							ui.draggable.draggable('option', 'revert', true);
						}
					})
					.appendTo("#griddle");
			};

			this.startTimer = function() {
				if (mechanics.crudDebug) {
					console.log("Starting crud shrink timer on " + this.id);
				}

            this.timer = window.setInterval(bindMe(this, this.shrink), mechanics.crudShrinkInterval);
			};

			this.stopTimer = function() {
				if (mechanics.crudDebug) {
					console.log("Stopping crud shrink timer on " + this.id);
				}

				window.clearInterval(this.timer);
				this.timer = null;
			};

			this.destroy = function() {
				if (mechanics.crudDebug) {
					console.log("Destroying " + this.id);
				}

				this.stopTimer();
            $(this.idHash).remove();
			};

			this.shrink = function() {
				if (mechanics.crudDebug) {
					console.log("Shrinking " + this.id);
				}

				var crudPos = $(this.idHash).position();
				var crudTop = crudPos.top + mechanics.crudShrinkSize;
				var crudLeft = crudPos.left + mechanics.crudShrinkSize;
				var crudWidth = $(this.idHash).width() - (mechanics.crudShrinkSize * 2);
				var crudHeight = $(this.idHash).height() - (mechanics.crudShrinkSize * 2);
				
				if (crudWidth > 0 && crudHeight > 0) {
               $(this.idHash)
                  .css("left", crudLeft + "px")
                  .css("top", crudTop + "px")
                  .css("width", crudWidth)
                  .css("height", crudHeight);
				} else {
               clearInterval(this.timer);

               // destroy this element
					this.destroy();
					griddle.removeCrud(this.id);
				}
			};
		};

      var Fire = function(startX, startY) {
			// increment the global firecounter everytime we create a new fire
         this.id = "";
			this.idHash = "";
         this.timer = null;

			this.draw = function() {
				// create a 1x1 div at the X and Y
				$("<div></div>")
					.attr("id", this.id)
					.addClass("fireBox")
					.css("width", 100)
					.css("height", 100)
					.css("top", startY)
					.css("left", startX)
					.droppable({
						greedy: true,
						tolerance: 'touch',
						drop: function(event, ui) {
							if (mechanics.dragDebug) {
								console.log("in the fire droppable drop!");
							}

							soundBuffer("sounds/error.mp3");
							ui.draggable.draggable('option', 'revert', true);
						}
					})
					.appendTo("#griddle");
			}

         this.startTimer = function() {
				if (mechanics.fireDebug) {
					console.log("Starting timer on " + this.id);
				}

            this.timer = window.setInterval(bindMe(this, this.grow), mechanics.fireGrowInterval);
         };

			this.stopTimer = function() {
				if (mechanics.fireDebug) {
					console.log("Stopping the fire timer on " + this.id);
				}

				window.clearInterval(this.timer);
				this.timer = null;
			}

         this.destroy = function() {
				if (mechanics.fireDebug) {
					console.log("Destroying a fire! " + this.id);
				}

            $(this.idHash).remove();
				this.stopTimer();
				griddle.removeFire(this.id);
         };

         this.grow = function() {
				if (mechanics.fireDebug) {
	            console.log("Growing the fire!");
				}

            // how far is the top of OUR div, from the top of the griddle div
            var griddlePos = $("#griddle").offset();
            var griddleRight = griddlePos.left + $("#griddle").width();
            var griddleBottom = griddlePos.top + $("#griddle").height();

            var firePos = $(this.idHash).offset();
            var fireRight = firePos.left + $(this.idHash).width();
            var fireBottom = firePos.top + $(this.idHash).height();

            var growTop = growLeft = growRight = growBottom = 0;

				if (mechanics.fireDebug) {
					console.log("Fire (Left: " + firePos.left + " Top: " + firePos.top + " Right: " + fireRight + " Bottom: " + fireBottom + " )");
					console.log("Griddle (Left: " + griddlePos.left + " Top: " + griddlePos.top + " Right: " + griddleRight + " Bottom: " + griddleBottom + " )");
				}

            // calculate the amount we should grow this step on top
            if ((firePos.top - mechanics.fireGrowSize) > griddlePos.top) {
               growTop = mechanics.fireGrowSize;
            } else if (firePos.top > griddlePos.top) {
               growTop = firePos.top - griddlePos.top;
            } else {
               growTop = 0;
            }

            if ((firePos.left - mechanics.fireGrowSize) > griddlePos.left) {
               growLeft = mechanics.fireGrowSize;
            } else if (firePos.left > griddlePos.left) {
               growLeft = firePos.left - griddlePos.left;
            } else {
               growLeft = 0;
            }

            if ((fireRight + mechanics.fireGrowSize) < griddleRight) {
               growRight = mechanics.fireGrowSize;
            } else if (fireRight < griddleRight) {
               growRight = griddleRight - fireRight;
            } else {
               growRight = 0;
            }

            if ((fireBottom + mechanics.fireGrowSize) < griddleBottom) {
               growBottom = mechanics.fireGrowSize;
            } else if (fireBottom < griddleBottom) {
               growBottom = griddleBottom - fireBottom;
            } else {
               growBottom = 0;
            }

				if (mechanics.fireDebug) {
	            console.log(growTop + "," + growLeft + "," + growRight + "," + growBottom);
				}

            if (growTop > 0 || growLeft > 0 || growRight > 0 || growBottom > 0) {
               var fireWidth = $(this.idHash).width() + growLeft + growRight;
               var fireHeight = $(this.idHash).height() + growTop + growBottom;
               var fireTop = firePos.top - growTop;
               var fireLeft = firePos.left - growLeft;

               $(this.idHash)
                  .css("left", fireLeft + "px")
                  .css("top", fireTop + "px")
                  .css("width", fireWidth)
                  .css("height", fireHeight);

					// check for collisions here
					for (var x = 0; x < griddle.patties.length; x++) {
						var obj1 = {
							top: $(griddle.patties[x].idHash).position().top,
							left: $(griddle.patties[x].idHash).position().left,
							width: $(griddle.patties[x].idHash).width(),
							height: $(griddle.patties[x].idHash).height()
						};

						var obj2 = {
							top: fireTop,
							left: fireLeft,
							width: fireWidth,
							height: fireHeight
						};

						if (overlaps(obj1, obj2)) {
							// this patty needs to be destroyed!
							$(griddle.removePatty(griddle.patties[x].id).idHash).remove();
						}
					}
            } else {
               clearInterval(this.timer);

               // destroy this element
               window.setTimeout(bindMe(this, this.destroy), mechanics.fireEndDelay);
            }
         }
      };

		var Patty = function(posTop, posLeft) {
			this.id = "";
			this.idHash = "";
			this.posTop = posTop || 0;
			this.posLeft = posLeft || 0;
			this.curSide = 0;
			this.flipSide = 0;
			this.cookable = true;
			this.dying = false;
			this.flips = 0;
			this.beefQuality = mechanics.pattyBeefQuality;
			
			this.cook = function() {
				if (this.cookable !== false) {
					this.curSide++;
				}

				if (this.curSide > mechanics.pattyMaxDone && this.cookable == true) {
					if (this.dying === false ) {
						var pattyPos = $(this.idHash).offset();
						this.cookable = false;
						this.dying = true;

						$(this.idHash)
							.fadeOut(300).fadeIn(300)
							.fadeOut(300).fadeIn(300)
							.fadeOut(300).fadeIn(300)
							.fadeOut(300).fadeIn(300)
							.fadeOut(300).fadeIn(300, function() {
								// remove the element
								griddle.removePatty(this.id);
								$(this).remove();
							});

						griddle.addFire(pattyPos.left, pattyPos.top);
						/*
						// there is a chance here that this will either cause a grease fire or form crud.
						var chance = Math.floor(Math.random() * 100) + 1;

						if (chance <= mechanics.pattyBurnNegChance) {
							var rand = Math.floor(Math.random() * 100) + 1;

							// 50% chance for either crud or fire
							if (rand <= 50) {
								griddle.addCrud(pattyPos.left, pattyPos.top);
							} else {
								griddle.addFire(pattyPos.left, pattyPos.top);
							} 
						}
						*/
					}
				}
			};

			this.flip = function() {
				var tmp = this.curSide;
				this.curSide = this.flipSide;
				this.flipSide = tmp;
				this.flips++;
			};

			this.cookedWell = function() {
				// being cooked "well" is anything not danger or bad
				var minDone = mechanics.pattyScores.ok.range;
				
				var curSide = (this.curSide > 100) ? 100 - (this.curSide - 100) : this.curSide;
				var flipSide = (this.flipSide > 100) ? 100 - (this.flipSide - 100) : this.flipSide;

				return ((100 - this.curSide) <= minDone && (100 - this.flipSide) <= minDone);
			}

			this.score = function() {
				if (mechanics.scoringDebug) {
					console.log("\tBurger Score");
					console.log("\t************");
				}

				var side1 = this.scoreSide(this.curSide);
				var side2 = this.scoreSide(this.flipSide);

				if (mechanics.scoringDebug) {
					console.log("\t(Lowest score of the two patty sides gets used)");
					console.log("\n");
				}

				var tmp = Math.min(side1, side2);

				// adjust with the heat modifier
				if (mechanics.scoringDebug) {
					console.log("\tHeat Modifier");
					console.log("\t*************");
				}

				var heatModifier = 1;
				var hmName = "";
				var subtractPer = 0;

				var heatPercent = 100 - ((this.remain / this.max) * 100);

				if (mechanics.scoringDebug) {
					console.log("\tHeat of patty (0 to 100): " + heatPercent);
				}

				if (heatPercent <= mechanics.heatModifiers.sizzling.range) {
					subtractPer = mechanics.heatModifiers.sizzling.subtract;
					hmName = "Sizzing";
				} else if (heatPercent <= mechanics.heatModifiers.warm.range) {
					subtractPer = mechanics.heatModifiers.warm.subtract;
					hmName = "Warm";
				} else if (heatPercent <= mechanics.heatModifiers.cold.range) {
					subtractPer = mechanics.heatModifiers.cold.subtract;
					hmName = "Cold";
				} else {
					subtractPer = mechanics.heatModifiers.stale.subtract;
					hmName = "Stale";
				}	

				heatModifier = (1 - (subtractPer / 100));

				if (mechanics.scoringDebug) {
					console.log("\tPatty heat level of " + hmName + " gets a heatModifier of -" + subtractPer + "% (" + heatModifier + ")\n");

					console.log("\tBeef Quality: " + this.beefQuality + "\n");

					console.log("\tPopularity: " + mechanics.popularity + "\n");

					console.log("\t((" + tmp + " * " + heatModifier + ") * " * this.beefQuality + ") * " + mechanics.popularity);
					console.log("\tFinal Patty Score: " + Math.floor(((tmp * heatModifier) * this.beefQuality) * mechanics.popularity));
					console.log("\t**********************");
				}

				return Math.floor(((tmp * heatModifier) * this.beefQuality) * mechanics.popularity);
			};

			this.scoreSide = function(doneness) {
				if (doneness > 100) {
					doneness = 100 - (doneness - 100);
				}

				donenessRange = 100 - doneness;

				if (mechanics.scoringDebug) {
					console.log("\tDoneness: " + doneness);
				}

				var cookedLevel = "";
				var score = 0;

				if (donenessRange <= mechanics.pattyScores.perfect.range) {
					cookedLevel = "PERFECT";
					score = mechanics.pattyScores.perfect.score;
				} else if (donenessRange <= mechanics.pattyScores.great.range) {
					cookedLevel = "GREAT";
					score = mechanics.pattyScores.great.score;
				} else if (donenessRange <= mechanics.pattyScores.ok.range) {
					cookedLevel = "OK";
					score = mechanics.pattyScores.ok.score;
				} else if (donenessRange <= mechanics.pattyScores.bad.range) {
					cookedLevel = "BAD";
					score = mechanics.pattyScores.bad.score;
				} else {
					cookedLevel = "DANGER";
					score = mechanics.pattyScores.danger.score;
				}

				if (mechanics.scoringDebug) {
					console.log("\tCooked level '" + cookedLevel + "' gets a score of " + score + "\n");
				}

				return score;
			};
		
			this.yulp = function() {
				return Math.min(this.yulpSide(this.curSide), this.yulpSide(this.flipSide));
			};

			this.yulpSide = function(doneness) {
				if (doneness > 100) {
					doneness = 100 - (doneness - 100);
				}

				donenessRange = 100 - doneness;

				if (donenessRange <= mechanics.pattyScores.perfect.range) {
					return mechanics.pattyScores.perfect.yulp;
				} else if (donenessRange <= mechanics.pattyScores.great.range) {
					return mechanics.pattyScores.great.yulp;
				} else if (donenessRange <= mechanics.pattyScores.ok.range) {
					return mechanics.pattyScores.ok.yulp;
				} else if (donenessRange <= mechanics.pattyScores.bad.range) {
					return mechanics.pattyScores.bad.yulp;
				} else {
					return mechanics.pattyScores.danger.yulp;
				}
			};
		};

      $(document).ready(function() {
			// griddle temperature controls
         $("#low").click(function() {
            griddle.turnOn(mechanics.griddleTempLow);
				$(this).css("background-color", "orange");
				$("#med").css("background-color", "");
				$("#high").css("background-color", "");
				$("#off").css("background-color", "");
         });

         $("#med").click(function() {
            griddle.turnOn(mechanics.griddleTempMed);
				$(this).css("background-color", "orange");
				$("#low").css("background-color", "");
				$("#high").css("background-color", "");
				$("#off").css("background-color", "");
         });

         $("#high").click(function() {
            griddle.turnOn(mechanics.griddleTempHigh);
				$(this).css("background-color", "orange");
				$("#low").css("background-color", "");
				$("#med").css("background-color", "");
				$("#off").css("background-color", "");
         });

         $("#off").click(function() {
            griddle.turnOff();
				$(this).css("background-color", "orange");
				$("#low").css("background-color", "");
				$("#med").css("background-color", "");
				$("#high").css("background-color", "");
         });

			$("#pause").click(function() {
				mechanics.pause();
			});

			$("#resume").click(function() {
				mechanics.resume();
			});

			$("#fillOrder").click(function() {
				// get the currentOrder
				var order = orderCollection.getOrder(orderCollection.currentOrder);

				// do we have enough patties to fill the current order?
				if (order) {
					if (prepTable.patties.length >= order.burgerCount) {
						// remove the patties from the preptable
						var orderPats = [];

						for (var x = 0; x < order.burgerCount; x++) {
							orderPats.push(prepTable.removeOldestPatty());
						}

						// mark the order as filled
						orderCollection.fillOrder(orderPats);
					} 
				}
			});

			$("#griddle").click(function(e) {
				if (!mechanics.paused) {
					// create a new patty
					var patty = new Patty(e.pageY - 50, e.pageX - 50);	

					var newPlacementObj = {
						top: e.pageY - 50,
						left: e.pageX - 50,
						width: 100,
						height: 100
					};

					// make sure this is a valid placement before we create
					var valid = true;

					// make sure we aren't colliding with another patty
					if (griddle.patties.length > 0) {
						for (var x = 0; x < griddle.patties.length; x++) {
							var pattyObj = {
								top: $(griddle.patties[x].idHash).position().top,
								left: $(griddle.patties[x].idHash).position().left,
								width: $(griddle.patties[x].idHash).width(),
								height: $(griddle.patties[x].idHash).height()
							};

							if (overlaps(pattyObj, newPlacementObj)) {
								if (mechanics.placementDebug) {
									console.log("Attempted patty drop overlaps an existing patty! " + griddle.patties[x].idHash);
								}

								valid = false;
							}
						}
					}

					// check we are within the confines of the griddle
					var obj2 = $("#griddle").position();

					if (!withinBounds(newPlacementObj, {top: obj2.top, left: obj2.left, width: $("#griddle").width(), height: $("#griddle").height()})) {
						if (mechanics.placementDebug) {
							console.log("Attempted patty drop is out of bounds of the griddle!");
						}

						valid = false;
					}

					// check if player has any patties left
					if (mechanics.dailyPatties == 0) {
						if (mechanics.placementDebug) {
							console.log("No patties left to drop!");
						}

						valid = false;
					}

					// make sure we aren't trying to place on top of some crud
					for (var x = 0; x < griddle.crud.length; x++) {
						var crudObj = {
							top: $(griddle.crud[x].idHash).position().top,
							left: $(griddle.crud[x].idHash).position().left,
							width: $(griddle.crud[x].idHash).width(),
							height: $(griddle.crud[x].idHash).height()
						}

						if (overlaps(crudObj, newPlacementObj)) {
							if (mechanics.placementDebug) {
								console.log("Attempted patty drop overlaps crud! " + griddle.crud[x].idHash);
							}

							valid = false;
						}
					}

					// make sure we're not placing in a fire!
					for (var x = 0; x < griddle.fires.length; x++) {
						var fireObj = {
							top: $(griddle.fires[x].idHash).position().top,
							left: $(griddle.fires[x].idHash).position().left,
							width: $(griddle.fires[x].idHash).width(),
							height: $(griddle.fires[x].idHash).height()
						}

						if (overlaps(fireObj, newPlacementObj)) {
							if (mechanics.placementDebug) {
								console.log("Attempted patty drop overlaps fire! " + griddle.fires[x].idHash);
							}

							valid = false;
						}
					}

					// add it to the griddle
					if (valid !== false) {
						griddle.addPatty(patty);
					} else {
						delete patty;

						soundBuffer("sounds/error.mp3");

						// show the collision box
						$("<div></div>")
							.addClass("colBox")
							.css("top", e.pageY - 50 + "px")
							.css("left", e.pageX - 50 + "px")
							.css("z-index", 1500)
							.appendTo("#griddle")
							.fadeIn(200).fadeOut(200).fadeIn(200).fadeOut(200, function() { $(this).remove(); });

					}
				}
			});

			$("#griddle").on("click", ".patty", function(e) {
				if (!mechanics.paused) {
					for (var x = 0; x < griddle.patties.length; x++) {
						if (griddle.patties[x].id == $(e.target).attr("id")) {
							if (griddle.patties[x].flips == (mechanics.pattyMaxFlips - 1)) {
								$(griddle.removePatty(griddle.patties[x].id).idHash).remove();
							} else {
								griddle.patties[x].flip();

								if (griddle.griddleOn) {
									soundBuffer("sounds/patty.mp3");
								}
							}

							griddle.draw();
						}
					}

					e.stopPropagation();
				}
			});

			$("#griddle").on("mousedown", ".patty", function(e) {
				if (!mechanics.paused) {
					for (var x = 0; x < griddle.patties.length; x++) {
						if (griddle.patties[x].id == $(e.target).attr("id")) {
							if (griddle.patties[x].dying === true) {
								$(griddle.patties[x].idHash).stop(true, true);
								$(griddle.patties[x].idHash).fadeIn(1);
								griddle.patties[x].dying = false;	
							} else {
								griddle.patties[x].cookable = false;
							}
						}
					}
				}
			});

			$("#griddle").on("mouseup", ".patty", function(e) {
				if (!mechanics.paused) {
					for (var x = 0; x < griddle.patties.length; x++) {
						if (griddle.patties[x].id == $(e.target).attr("id")) {
							var id = "" + e.toElement.id;
							//console.log(id + ": " + id.indexOf("slot"));
							if ((id != "preptable") && (id.indexOf("slot") == -1)) {
								//console.log("setting cookable to true fart");
								//console.log(e.toElement);
								griddle.patties[x].cookable = true;
							} 
						}
					}
				}
			});

			$(".patty").mouseout(function(e) {
				if (!mechanics.paused) {
					for (var x = 0; x < griddle.patties.length; x++) {
						if (griddle.patties[x].id == $(e.target).attr("id")) {
							console.log("setting cookable to true! #2");	
							griddle.patties[x].cookable = true;
						}
					}
				}
			});

			$("#griddle").droppable({
				 tolerance: 'fit'
			});

			$("#preptable").droppable({
				tolerance: "fit",
				drop: function(e, ui) {
					// check the doneness values
					for (var x = 0; x < griddle.patties.length; x++) {
						var patty = griddle.patties[x];

						if (griddle.patties[x].id == ui.draggable.attr("id")) {
							patty.cookable = false;

							if (griddle.patties[x].cookedWell()) {
								$("#" + ui.draggable.attr("id")).html("<img src='images/thumbsup.png' />");
							} else {
								$("#" + ui.draggable.attr("id")).html("<img src='images/thumbsdown.png' />");
							}

							if ((prepTable.patties.length + 1) == mechanics.prepTableSlots[mechanics.prepTableLevel]) {
								$("#preptable").droppable("disable");
							}

							$("#" + ui.draggable.attr("id")).fadeOut(300).fadeIn(300).fadeOut(300).fadeIn(300).delay(500).fadeOut(300, function() { 
								prepTable.addPatty(griddle.removePatty(ui.draggable.attr("id")));
								$(this).remove();
							});
						}
					}
				}
			});

			$("#floor").droppable({
				tolerance: "fit",
				drop: function(e, ui) {
					griddle.removePatty(ui.draggable.attr("id"));
					$("#" + ui.draggable.attr("id")).remove();
					player.garbage++;
				}
			});

			/*
			$(".crudBox").droppable({
				greedy: true,
				drop: function(e, ui) {
					if (mechanics.crudDebug || mechanics.dragDebug) {
						console.log("dropped on a crudbox");
					}
				}
			});

			$(".fireBox").droppable({
				greedy: true,
				drop: function(e, ui) {
					if (mechanics.fireDebug || mechanics.dragDebug) {
						console.log("dropped on a fire!");
					}
				}
			});
			*/

			mechanics.nextOrder = window.setTimeout(function() {
				var order = new Order();
				var val = Math.floor(Math.random() * (mechanics.orderBurgerCountUpper - mechanics.orderBurgerCountLower)) + mechanics.orderBurgerCountLower;

				if (mechanics.orderDebug) {
					console.log("Math.floor(Math.random() * (" + mechanics.orderBurgerCountUpper + " - " + mechanics.orderBurgerCountLower + ")) + " + mechanics.orderBurgerCountLower + " = " + val);
				}

				order.burgerCount = val;
				order.maxAge = Math.floor(Math.random() * (mechanics.orderMaxAgeUpper - mechanics.orderMaxAgeLower)) + mechanics.orderMaxAgeLower;
				orderCollection.addOrder(order);
			}, Math.floor(Math.random() * (mechanics.initialOrderDelayUpper - mechanics.initialOrderDelayLower) + mechanics.initialOrderDelayLower));

			prepTable.draw();

			$("#instructions").dialog(mechanics.popUpDefaults);
			$("#store").dialog(mechanics.popUpDefaults);
			$("#statistics").dialog(mechanics.popUpDefaults);

			$("#showInstructions").click(function() {
				$("#instructions").dialog("open");
			});

			$("#showStore").click(function() {
				$("#store").dialog("open");
			});

			$("#showStatistics").click(function() {
				$("#statistics").dialog("open");
			});
		});
		</script>
	</head>
	<body>
		<!--<div id="fb-root"></div>
		<script>
		// Additional JS functions here
		window.fbAsyncInit = function() {
			FB.init({
				appId: '556572957743233', // App ID
				channelUrl: '//192.168.244.131/channel.html', // Channel File
				status: true, // check login status
				cookie: true, // enable cookies to allow the server to access the session
				xfbml: true  // parse XFBML
			});

			// Additional init code here
			FB.Event.subscribe('auth.authResponseChange', function(response) {
				// Here we specify what we do with the response anytime this event occurs. 
				if (response.status === 'connected') {
					testAPI();
				} else if (response.status === 'not_authorized') {
					FB.login();
				} else {
					FB.login();
				}
			});
		};

		// Load the SDK asynchronously
		(function(d){
			var js, id = 'facebook-jssdk', ref = d.getElementsByTagName('script')[0];
			if (d.getElementById(id)) {return;}
			js = d.createElement('script'); js.id = id; js.async = true;
			js.src = "//connect.facebook.net/en_US/all.js";
			ref.parentNode.insertBefore(js, ref);
		}(document));

		function testAPI() {
			console.log('Welcome!  Fetching your information.... ');
			FB.api('/me', function(response) {
				console.log('Good to see you, ' + response.name + '.');
			});
		}
		</script>-->
		<div id='ovencontrols'>
			<button id='off' style='background-color: orange;'>Off</button>
			<button id='low'>Low</button>
			<button id='med'>Med</button>
			<button id='high'>High</button>
			<button id='pause'>Pause Game</button>
			<button style='display: none;' id='resume'>Resume Game</button>
		</div>
		<div id='topBox'>
			<div id='scoreBox'>Score: <span id='curScore'>0</span></div>
			<div id='tipBox'>Tips: $<span id='curTips'>0.00</span></div>
			<div id='burgerBox'>Burgers: <span id='curBurgers'>30</span></div>
		</div>
		<div id='workspace'>
			<div id='griddleFill'>
				<div id='griddle'>
				</div>
			</div>
			<div id='preptable'>
				<button id='fillOrder'>Fill Order</button>
			</div>
			<div id='floor'>
			</div>
		</div>
		<div id='adminSpace'>
			<div id='currentOrder'>
				Order #<span class='orderNumber'>-</span>
				Burgers: <span class='burgerCount'>-</span>
				Age: <span class='orderAge'>-</span>
				<div id='currentOrderBG'></div>
			</div>
			<div id='orderCollection'>
				Total Orders: <span class='totalOrders'>0</span>
				Burgers All Day: <span class='burgersAllDay'>0</span>	
				Orders Filled: <span class='ordersFilled'>0</span>
			</div>
			<div id='buffBox'>
				<div id='buffFireExtinguisher' class='buff' title='Fire Extinguisher'><span id='buffFireExtinguisherCount' class='buffCount'>0</span></div>
				<div id='buffMicrowave' class='buff' title='Microwave'><span id='buffMicrowaveCount' class='buffCount'>0</span></div>
				<div id='buffScraper' class='buff' title='Scraper'><span id='buffScraperCount' class='buffCount'>0</span></div>
				<div id='buffPause' class='buff' title='Pause'><span id='buffPauseCount' class='buffCount'>0</span></div>
				<div id='buffHeatLamp' class='buff' title='Heat Lamp'><span id='buffHeatLampCount' class='buffCount'>0</span></div>
				<div id='buffTwitter' class='buff' title='Twitter'><span id='buffTwitterCount' class='buffCount'>0</span></div>
				<div id='buffSauce' class='buff' title='Special Sauce'><span id='buffSauceCount' class='buffCount'>0</span></div>
				<div id='buffHelper' class='buff' title='Helper'><span id='buffHelperCount' class='buffCount'>0</span></div>
			</div>
			<div id='yulpBox'>Yulp: <span id='curYulp'>&#9733;&#9733;&#9734;&#9734;&#9734;</span></div>
			<div id='menuBar'>
				<button id='showInstructions'>Instructions</button>
				<button id='showStore'>Store</button>
				<button id='showStatistics'>Statistics</button>
				<button id='closeShop'>Close Shop</button>
				<button id='exit'>Exit</button>
				<div id='loginsBox'>
					<span id="signinButton">
					  <span
						 class="g-signin"
						 data-callback="signinCallback"
						 data-clientid="171967825850.apps.googleusercontent.com"
						 data-cookiepolicy="single_host_origin"
						 data-requestvisibleactions="http://schemas.google.com/AddActivity"
						 data-scope="https://www.googleapis.com/auth/plus.login">
					  </span>
					</span>
					<!--<fb:login-button show-faces="true" width="200" max-rows="1"></fb:login-button> -->
				</div>
			</div>
			<div id='instructions'>
				<p>Welcome to Burger Bus... a new project by fdask.</p>
				<p>The goal here is to simulate cooking some burgers on a flat top!</p>
				<p>On the left there, you have three areas... a griddle (upper left), a prep table (upper right), and the floor (bottom).</p>
				<p>To get started, click anywhere on the griddle to slap down a new patty.  Then turn on the griddle using the button at the top left.</p>
				<p>As the patty cooks, you will see the % in the upper right corner increase.  Once the doneness of the patty approaches 100%, click it to flip it over and start cooking the other side.</p>
				<p>When both sides are as close to 100% as you can get them, drag the patty over on to the prep area on the right.  You will get either a thumbs up or a thumbs down depending on how well the patty has been cooked.</p>
				<p>If you accidentally burn a burger, you can discard it by dragging it to the floor area below the griddle.</p>
				<p>Good luck and happy cooking!</p>
			</div>
			<div id='store'>
			</div>
			<div id='statistics'>
			</div>
		</div>
		<!--<script type="text/javascript">
		(function() {
			var po = document.createElement('script'); 
			po.type = 'text/javascript'; 
			po.async = true;
			po.src = 'https://apis.google.com/js/client:plusone.js';
			var s = document.getElementsByTagName('script')[0]; 
			s.parentNode.insertBefore(po, s);
http://stackoverflow.com/questions/17159743/how-to-stop-google-sign-in-button-from-popping-up-the-message-welcome-back-yo
		})();
		</script>-->
	</body>
</html>
